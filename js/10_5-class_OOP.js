//! ========== Объектно-ориентированное программирование =========================

// Процедурное программирование - набор не связанных явно функций и переменных для хранения и обработки информации.
// Этот подход прост и прямолинеен и подходит для задач где нет тесно связанных сущностей(данных и функций для их обработки).

//* Рассмотрим пример процедурного кода где есть переменные и функция для подсчета результата.

// const baseSalary = 30000;
// const overtime = 10;
// const rate = 20;

// const getWage = (baseSalary, overtime, rate) => {
//   return baseSalary + overtime * rate;
// };

// getWage(baseSalary, overtime, rate);

//* Объектно - ориентированное программирование(ООП) - методология, основанная на представлении программы в виде совокупности объектов,
// каждый из которых содержит данные(свойства) и методы для взаимодействия с ними.

// Используем ООП, собрав данные в объект employee.

// const employee = {
//   baseSalary: 30000,
//   overtime: 10,
//   rate: 20,
//   getWage() {
//     return this.baseSalary + this.overtime * this.rate;
//   },
// };

// employee.getWage();

// При таком подходе у метода нету параметров, используются свойства объекта, которые задаются при создании объекта и, возможно,
// так же изменяются другими методами. На выходе получаем сущность с простым интерфейсом, что понижает сложность программы.


//! ============================ Прототипное наследование ===========================================================================
// ООП в JavaScript построено на прототипном наследовании.
// Объекты можно организовать в цепочки так, чтобы свойство не найденное в одном объекте, автоматически искалось бы в другом.
// Связующим звеном выступает специальное скрытое свойство[[Prototype]], которое в консоли браузера отображается как __proto__.

//? Прототип объекта

//* Метод Object.create(obj) создаёт и возвращает новый объект, связывая его с объектом obj.

// const animal = {
//   legs: 4,
// };
// const dog = Object.create(animal);
// dog.name = "Манго";

// console.log(dog); // { name: 'Манго', __proto__: animal }
// console.log(animal.isPrototypeOf(dog)); // true

// Объект, на который указывает ссылка в __proto__, называется прототипом.В нашем примере объект animal это прототип для объекта dog.
// Метод isPrototypeOf() проверяет является ли объект animal прототипом для dog и возвращает true или false.

// console.log(dog.hasOwnProperty("name")); // true
// console.log(dog.name); // 'Манго'

// console.log(dog.hasOwnProperty("legs")); // false
// console.log(dog.legs); // 4

// Обращение dog.name работает очевидным образом - возвращает собственное свойство name объекта dog.
// При обращении к dog.legs интерпретатор ищет свойство legs в объекте dog, не находит и продолжает поиск в объекте по ссылке из dog.__proto__,
// то есть, в данном случае, в объекте animal - его прототипе.

//! ================================== Метод hasOwnProperty() =======================================================

//* После того как мы узнали о том, как происходит поиск свойств объекта, должно стать понятно,
//* почему цикл for...in не делает различия между свойствами объекта и его прототипа.

// const animal = { eats: true };
// const dog = Object.create(animal);
// dog.barks = true;

// for (const key in dog) {
//   console.log(key); // barks, eats
// }

//* Именно поэтому мы используем метод obj.hasOwnProperty(prop), который возвращает true, если свойство prop принадлежит самому объекту obj,
//* а не его прототипу, иначе false.

// const animal = {
//   eats: true,
// };
// const dog = Object.create(animal);
// dog.barks = true;

// for (const key in dog) {
//   if (!dog.hasOwnProperty(key)) continue;

//   console.log(key); // barks
// }

//* Метод Object.keys(obj) вернет массив только собственных ключей объекта obj, поэтому на практике используют именно его, а не for...in.

// const animal = {
//   eats: true,
// };
// const dog = Object.create(animal);
// dog.barks = true;

// const dogKeys = Object.keys(dog);

// console.log(dogKeys); // ['barks']

//todo =============================================== Классы =========================================================================
//! ================================================ Классы ===========================================================================
//todo =============================================== Классы =========================================================================

// Синтаксис литерала объекта позволяет создать один объект.Но часто нужно создать много однотипных объектов с одинаковым набором свойств,
// но разными значениями и методами для взаимодействия с ними.Всё это нужно сделать динамичекски, во время выполнения программы.
// Для этого используют классы - специальный синтаксис объявления функции для создания объектов.

//? Объявление класса ================

//* Объявление класса начинается с ключевого слова class, после которого идёт имя класса и фигурные скобки - его тело.
//* Классы принято называть с большой буквы, а в самом названии отражать тип создаваемого объекта(существительное).

// class User {
//   // Тело класса
// }

// const mango = new User();
// console.log(mango); // {}

// const poly = new User();
// console.log(poly); // {}

// Результат вызова new User() это объект, который называется экземпляр класса, потому что содержит данные и поведение, описываемые классом.

//? Конструктор класса =================

//* Для инициализации экземпляра в классе есть метод constructor.
//* Если он не объявлен, создаётся конструктор по умолчанию - пустая функция, которая не изменяет экземпляр.

// class User {
//   // Синтаксис объявления метода класса
//   constructor(name, email) {
//     // Инициализация свойств экземпляра
//     this.name = name;
//     this.email = email;
//   }
// }

// const mango = new User("Манго", "mango@mail.com");
// console.log(mango); // { name: 'Манго', email: 'mango@mail.com' }

// const poly = new User("Поли", "poly@mail.com");
// console.log(poly); // { name: 'Поли', email: 'poly@mail.com' }

// Вызов класса с оператором new приводит к созданию нового объекта и вызову конструктора в контексте этого объекта.
// То есть this внутри конструктора будет ссылаться на новосозданный объект.
// Это позволяет добавлять каждому объекту свойства с одинаковыми именами, но разными значениями.

// Свойства name и email называются публичные свойства, потому что они будут собственными свойствами объекта - экземпляра
// и к ним можно будет получить доступ обратившись через точку.

//? Объект параметров ================

// Класс может принимать большое количество входных данных для свойств будущего объекта.Поэтому к ним также можно применить паттерн «Объект параметров,
// передавая один объект с логично именованными свойствами, вместо несвязанного набора аргументов.

// class User {
//   // Деструктуризируем объект
//   constructor({ name, email }) {
//     this.name = name;
//     this.email = email;
//   }
// }

// const mango = new User({
//   name: "Манго",
//   email: "mango@mail.com",
// });
// console.log(mango); // { name: "Манго", email: "mango@mail.com" }

// const poly = new User({
//   name: "Поли",
//   email: "poly@mail.com",
// });
// console.log(poly); // { name: "Поли", email: "poly@mail.com" }


//todo ============== Пример создания класа от Репеты с пояснением =========================================


const Car = function ({ brand, model, price } = {}) { //* принимает параметры (деструктуризированные) и по умолчанию {}
    //* 2) Функция вызывается в контексте созданного объекта, т.е. в this записывается ссылка на него

    this.brand = brand;
    this.model = model;
    this.price = price;

    //* 4) Ссылка на объект вовращается в место вызова new Car
}

//* прототип который сделан у Car для изменения цены (доступен у всех ЭК) . Лучше методы делать не внутри класа а в prototype (без дублирования)
Car.prototype.changePrice = function (newPrice) { 
    this.price = newPrice;
};

//* 1) Если функция вызывается через new , создаётся пустой объект (ЭК) который мы наполняем
const myCar = new Car({
    brand: 'Audi',
    model: 'Q7',
    price: 60000,
});

const myCar2 = new Car({ brand: 'BMW', model: 'X6', price: 70000 }); // новый ЭК
const myCar3 = new Car({ brand: 'BMW', model: 'X3', price: 35000 }); // новый ЭК

console.log(myCar2); // Car {brand: 'BMW', model: 'X6', price: 70000}
myCar2.changePrice(85000); //* изменили цену через prototype класа Car
console.log(myCar2); // Car {brand: 'BMW', model: 'X6', price: 85000}

//? Методы класса ===================

// Для работы со свойствами будущего экземпляра используются методы класса - функции которые будут доступны экземпляру в его прототипе.

// class User {
//   constructor({ name, email }) {
//     this.name = name;
//     this.email = email;
//   }

//   // Метод getEmail
//   getEmail() {
//     return this.email;
//   }

//   // Метод changeEmail
//   changeEmail(newEmail) {
//     this.email = newEmail;
//   }
// }


//? Приватные свойства ====================

// Инкапсуляция - это концепция позволяющая скрыть внутренние детали класса.
// Пользователь класса должен получать доступ только к публичному интерфейсу - набору публичных свойств и методов класса.

// В классах инкапсуляция реализуется приватными свойствами, доступ к которым можно получить только внутри класса.

// Допустим, почта пользователя должна быть недоступна для прямого изменения из вне, то есть приватна.
//* Добавляя к имени свойства символ # мы делаем его приватным.Объявление приватного свойства до инициализации в конструкторе - обязательно.

// class User {
//   // Необязательное объявление публичных свойств
//   name;
//   // Обязательное объявление приватных свойств
//   #email;

//   constructor({ name, email }) {
//     this.name = name;
//     this.#email = email;
//   }

//   getEmail() {
//     return this.#email;
//   }

//   changeEmail(newEmail) {
//     this.#email = newEmail;
//   }
// }

// const mango = new User({
//   name: "Манго",
//   email: "mango@mail.com",
// });
// mango.changeEmail("mango@supermail.com");
// console.log(mango.getEmail()); // mango@supermail.com
// console.log(mango.#email); // Будет ошибка, это приватное свойство

// Методы класса также могут быть приватными, то есть доступны только в теле класса. Для этого перед их именем необходимо поставить символ #.


//? Геттеры и сеттеры ==============

// Геттеры и сеттеры - это более краткий синтаксис объявления методов для взаимодействия со свойствами.
// Геттер и сеттер имитируют обычное публичное свойство класса, но позволяют изменять другие свойства более удобным способом.
// Геттер выполняется при попытке получить значение свойства, а сеттер - при попытке его изменить.
// Геттеры и сеттеры хорошо использовать для простых операций чтения и изменения значения свойств, особенно приватных, как их публичный интерфейс.
// Для работы со свойством которое хранит массив или объект они не подойдут.

// class User {
//   #email;

//   constructor({ name, email }) {
//     this.name = name;
//     this.#email = email;
//   }

//   // Геттер email
//   get email() {
//     return this.#email;
//   }

//   // Сеттер email
//   set email(newEmail) {
//     this.#email = newEmail;
//   }
// }

// Мы объявили геттер и сеттер email поставив перед именем свойства ключевые слова get и set.
// Внутри этих методов мы или возвращаем значение приватного свойства #email или изменяем его значение.
// Геттер и сеттер идут впаре и должны называться одинаково.

// const mango = new User({ name: "Манго", email: "mango@mail.com" });
// console.log(mango.email); // mango@mail.com
// mango.email = "mango@supermail.com";
// console.log(mango.email); // mango@supermail.com

// При обращении к mango.email вызызвается геттер get email() {... } и выполняется его код.
// При попытке записи mango.email = "mango@supermail.com" вызывается сеттер set email(newEmail) {... } и строка "mango@supermail.com"
// будет значением параметра newEmail.
// Плюс в том, что это методы, а значит при записи можно выполнить дополнительный код, например с какими - то проверками,
// в отличии от выполнениях этой же операции напрямую со свойством.

// set email(newEmail) {
//   if(newEmail === "") {
//     console.error("Ошибка! Почта не может быть пустой строкой!");
//     return;
//   }

//   this.#email = newEmail;
// }

//? Статические свойства =====================

// Кроме публичных и приватных свойств будущего экземпляра, в классе можно объявить его собственные свойства, доступные только классу,
// но не его экземплярам - статические свойства(static).Они полезны для хранения информации относящейся к самому классу.
// Добавим классу пользователя приватное свойство role - его роль, определяющую набор прав, например администратор, редактор,
// просто пользователь и т п.Возможные роли пользователей будем хранить как статическое свойство Roles - объект со свойствами.
//* Статические свойства объявляются в теле класса. Перед именем свойства добавляется ключевое слово static.

// class User {
//   // Объявление и инициализация статического свойства
//   static Roles = {
//     ADMIN: "admin",
//     EDITOR: "editor",
//   };

//   #email;
//   #role;

//   constructor({ email, role }) {
//     this.#email = email;
//     this.#role = role;
//   }

//   get role() {
//     return this.#role;
//   }

//   set role(newRole) {
//     this.#role = newRole;
//   }
// }

// const mango = new User({
//   email: "mango@mail.com",
//   role: User.Roles.ADMIN,
// });

// console.log(mango.Roles); // undefined
// console.log(User.Roles); // { ADMIN: "admin", EDITOR: "editor" }

// console.log(mango.role); // "admin"
// mango.role = User.Roles.EDITOR;
// console.log(mango.role); // "editor"

// Статические свойства также могут быть приватные, то есть доступные только внутри класса.
// Для этого имя свойства должно начинаться с символа #, также как приватные свойства.
// Обращение к приватному статическому свойству вне тела класса вызовет ошибку.

//? Статические методы ========================

// В классе можно объявить не только методы будущего экземпляра, но и методы доступные только классу - статические методы,
// которые могут быть как публичные так и приватные.
// Синтаксис объявления аналогичен статическим свойствам, за исключением того что значением будет метод.

// class User {
//   static #takenEmails = [];

//   static isEmailTaken(email) {
//     return User.#takenEmails.includes(email);
//   }

//   #email;

//   constructor({ email }) {
//     this.#email = email;
//     User.#takenEmails.push(email);
//   }
// }

// const mango = new User({ email: "mango@mail.com" });

// console.log(User.isEmailTaken("poly@mail.com"));
// console.log(User.isEmailTaken("mango@mail.com"));

// Особенность статических методов в том, что во время их вызова ключевое слово this ссылается на сам класс.
// Это значит что статический метод может получить доступ к статическим свойствам класса, но не к свойствам экземпляра.
// Логично, потому что статические методы вызывает сам класс, а не его экземпляры.

//? Наследование классов =============================

//* Ключевое слово extends позволяет реализовать наследование классов, когда один класс (дочерний, производный) наследует свойства и методы другого класса (родителя).

// class Child extends Parent {
//   // ...
// }

//* В выражении class Child extends Parent дочерний класс Child наследует (расширяет) от родительского класса Parent.

// Можно сделать общий класс User, который будет хранить набор общих свойств и методов, после чего сделать классы для каждого типа пользователя которые наследуют этот набор от класса User.
// При необходимости изменить что - то общее, достаточно будет поменять только код класса User.

// class User {
//   #email;

//   constructor(email) {
//     this.#email = email;
//   }

//   get email() {
//     return this.#email;
//   }

//   set email(newEmail) {
//     this.#email = newEmail;
//   }
// }

// class ContentEditor extends User {
//   // Тело класса ContentEditor
// }

// const editor = new ContentEditor("mango@mail.com");
// console.log(editor); // { email: "mango@mail.com" }
// console.log(editor.email); // "mango@mail.com"

// Класс ContentEditor наследует от класса User его конструктор, геттер и сеттер email, а также одноимённое публичное свойство.
//* Важно помнить что приватные свойства и методы класса - родителя не наследуются классом - ребёнком.


//? Конструктор дочернего класса ==============================

//* Первым делом в конструкторе дочернего класса необходимо вызвать специальную функцию super(аргументы) - это псевдоним конструктора родительского класса.
// В противном случае, при попытке обратиться к this в конструкторе дочернего класса, будет ошибка.
// При вызове конструктора класса родителя передаём необходимые ему аргументы для инициализации свойств.

// class User {
//   #email;

//   constructor(email) {
//     this.#email = email;
//   }

//   get email() {
//     return this.#email;
//   }

//   set email(newEmail) {
//     this.#email = newEmail;
//   }
// }

// class ContentEditor extends User {
//   constructor({ email, posts }) {
//     // Вызов конструктора родительского класса User
//     super(email);
//     this.posts = posts;
//   }
// }

// const editor = new ContentEditor({ email: "mango@mail.com", posts: [] });
// console.log(editor); // { email: 'mango@mail.com', posts: [] }
// console.log(editor.email); // 'mango@mail.com'

//? Методы дочернего класса =======================

// В дочернем классе можно объявлять методы которые будут доступны только его экземплярам.

// class User {
//   #email;

//   constructor(email) {
//     this.#email = email;
//   }

//   get email() {
//     return this.#email;
//   }

//   set email(newEmail) {
//     this.#email = newEmail;
//   }
// }

// class ContentEditor extends User {
//   constructor({ email, posts }) {
//     super(email);
//     this.posts = posts;
//   }

//   addPost(post) {
//     this.posts.push(post);
//   }
// }

// const editor = new ContentEditor({ email: "mango@mail.com", posts: [] });
// console.log(editor); // { email: 'mango@mail.com', posts: [] }
// console.log(editor.email); // 'mango@mail.com'
// editor.addPost("post-1");
// console.log(editor.posts); // ['post-1']